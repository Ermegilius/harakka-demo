/**
 * Supabaseâ€‘centric notification helpers
 * ------------------------------------
 * Contains a tiny wrapper around Realtime so the rest of the UI
 * can subscribe to a userâ€‘scoped stream of `public.notifications` rows
 * without worrying about SQL filters or channel names.
 */
import { supabase } from "@/config/supabase";
import { RealtimePostgresInsertPayload } from "@supabase/supabase-js";
import { DBTables } from "@common/database.types";

/**
 * Database row as generated by `supabase gen types`.
 * We alias it here purely for convenience.
 */
export type NotificationRow = DBTables<"notifications">;

/**
 * Subscribes to **unread** notifications for a single user.
 *
 * The helper does two things:
 * 1. Immediately fetches all rows that are still `read_at IS NULL`
 *    so badges are correct after a full page reload.
 * 2. Opens a Realtime channel (`public:notifications`) and pushes every
 *    subsequent INSERT for that user into `onNew`.
 *
 * @param userId â€“ `auth.user().id`
 * @param onNew  â€“ callback invoked with each fresh `notifications` row
 * @returns      â€“ `unsubscribe()` â€“ always call this in `useEffect` cleanup
 *
 * @example
 * ```ts
 * useEffect(() => {
 *   const unsub = subscribeToNotifications(user.id, n =>
 *     setFeed(prev => [n, ...prev])
 *   );
 *   return unsub;        // <- important!
 * }, [user.id]);
 * ```
 */
export function subscribeToNotifications(
  userId: string,
  onNew: (n: NotificationRow) => void,
): () => void {
  console.log("ðŸ”” [DEBUG] Setting up notifications for user:", userId);

  // -------- initial unread fetch
  supabase
    .from("notifications")
    .select("*")
    .eq("user_id", userId)
    .is("read_at", null)
    .order("created_at", { ascending: false })
    .then(({ data, error }) => {
      console.log("ðŸ”” [DEBUG] Initial fetch result:", {
        data,
        error,
        count: data?.length || 0,
      });
      if (error) {
        console.error("ðŸ”” [DEBUG] Initial fetch error:", error);
      } else {
        console.log(
          "ðŸ”” [DEBUG] Found",
          data?.length || 0,
          "unread notifications",
        );
        data?.forEach((notification, index) => {
          console.log(`ðŸ”” [DEBUG] Notification ${index + 1}:`, notification);
          onNew(notification);
        });
      }
    });

  // -------- live inserts via Realtime
  console.log("ðŸ”” [DEBUG] Setting up Realtime subscription...");
  const channel = supabase
    .channel("user:notifications")
    .on(
      "postgres_changes",
      {
        event: "INSERT",
        schema: "public",
        table: "notifications",
        filter: `user_id=eq.${userId}`,
      },
      (payload: RealtimePostgresInsertPayload<NotificationRow>) => {
        console.log("ðŸ”” [DEBUG] Realtime notification received:", payload);
        onNew(payload.new);
      },
    )
    .subscribe((status) => {
      console.log("ðŸ”” [DEBUG] Realtime subscription status:", status);
    });

  // -------- caller's cleanup
  return () => {
    console.log("ðŸ”” [DEBUG] Cleaning up notification subscription");
    void supabase.removeChannel(channel);
  };
}
