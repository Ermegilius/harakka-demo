/**
 * Supabase‑centric notification helpers
 * ------------------------------------
 * Contains a tiny wrapper around Realtime so the rest of the UI
 * can subscribe to a user‑scoped stream of `public.notifications` rows
 * without worrying about SQL filters or channel names.
 */
import { supabase } from "@/config/supabase";
import { RealtimePostgresInsertPayload } from "@supabase/supabase-js";
import { DBTables } from "@common/database.types";

/**
 * Database row as generated by `supabase gen types`.
 * We alias it here purely for convenience.
 */
export type NotificationRow = DBTables<"notifications">;

/**
 * Subscribes to **unread** notifications for a single user.
 *
 * The helper does two things:
 * 1. Immediately fetches all rows that are still `read_at IS NULL`
 *    so badges are correct after a full page reload.
 * 2. Opens a Realtime channel (`public:notifications`) and pushes every
 *    subsequent INSERT for that user into `onNew`.
 *
 * @param userId – `auth.user().id`
 * @param onNew  – callback invoked with each fresh `notifications` row
 * @returns      – `unsubscribe()` – always call this in `useEffect` cleanup
 *
 * @example
 * ```ts
 * useEffect(() => {
 *   const unsub = subscribeToNotifications(user.id, n =>
 *     setFeed(prev => [n, ...prev])
 *   );
 *   return unsub;        // <- important!
 * }, [user.id]);
 * ```
 */
export function subscribeToNotifications(
  userId: string,
  onNew: (n: NotificationRow) => void,
): () => void {
  const isDebugEnabled = (): boolean => {
    try {
      if (typeof window !== "undefined") {
        const ls = window.localStorage?.getItem("notifDebug");
        if (ls && ls !== "0" && ls !== "false") return true;
        const qp = new URLSearchParams(window.location.search);
        if (qp.get("notifDebug") === "1") return true;
        if (/localhost|127\.0\.0\.1/.test(window.location.hostname)) return true;
      }
      const vite = (import.meta as any)?.env;
      if (vite?.DEV === true) return true;
      if (vite?.MODE === "development") return true;
      const nodeEnv = (typeof process !== "undefined" ? (process as any).env?.NODE_ENV : undefined);
      if (nodeEnv === "development") return true;
    } catch {}
    return false;
  };
  const dlog = (...args: unknown[]) => {
    if (isDebugEnabled()) console.log("[NotifLib]", ...args);
  };

  // -------- initial unread fetch
  dlog("Initial fetch", { userId });
  supabase
    .from("notifications")
    .select("*")
    .eq("user_id", userId)
    .is("read_at", null)
    .order("created_at", { ascending: false })
    .then(({ data, error }) => {
      if (error) {
        console.error("Failed to fetch initial notifications:", error);
      } else {
        dlog("Initial rows", { count: data?.length ?? 0 });
        data?.forEach((notification) => {
          dlog("Initial row", {
            id: notification.id,
            type: notification.type,
            sev: notification.severity,
            created_at: notification.created_at,
            metadata: notification.metadata,
          });
          onNew(notification);
        });
      }
    });

  // -------- live inserts via Realtime
  dlog("Subscribe channel", { channel: "user:notifications" });
  const channel = supabase
    .channel("user:notifications")
    .on(
      "postgres_changes",
      {
        event: "INSERT",
        schema: "public",
        table: "notifications",
        filter: `user_id=eq.${userId}`,
      },
      (payload: RealtimePostgresInsertPayload<NotificationRow>) => {
        dlog("Realtime insert", {
          id: payload.new.id,
          type: payload.new.type,
          sev: payload.new.severity,
          created_at: payload.new.created_at,
          metadata: payload.new.metadata,
        });
        onNew(payload.new);
      },
    )
    .subscribe();

  // -------- caller's cleanup
  return () => {
    dlog("Remove channel");
    void supabase.removeChannel(channel);
  };
}
